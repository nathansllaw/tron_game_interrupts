# Tron Light Cycle (Interrupt-Driven)

A **Tron-style light cycle game** implemented in **C** for a **Nios V softcore processor** running on an **FPGA VGA platform** (e.g. Intel DE10-Lite / CPUlator).

This version uses a **hardware timer (MTIME)** and **interrupt-driven input** to control gameplay timing and responsiveness. Game logic is executed inside interrupt service routines (ISRs) rather than a polling loop.

The system allows a user to:
- Control a human player using pushbutton interrupts
- Compete against an AI-controlled opponent
- Run gameplay logic on precise hardware-timed intervals
- Dynamically adjust game speed using switches
- Track scores using seven-segment displays
- Render gameplay using VGA graphics

---

## Overview

This project implements a two-player Tron game using:
- MTIME-based hardware timing
- Interrupt-driven pushbutton input
- Timer-scheduled game updates
- Direct memory-mapped VGA pixel buffer access
- Rule-based AI for the robot player
- Centralized trap handling for interrupts

The design emphasizes **hardware-accurate timing, responsiveness, and scalability**, representing a more advanced embedded architecture.

---

## System Architecture

- Interrupt-driven control flow
- Machine timer (MTIME) for periodic game ticks
- Pushbutton input handled via KEY interrupts
- Central trap handler (`mtvec`) for dispatching ISRs
- Minimal main loop (event-driven execution)

---

## Platform

- Nios V softcore CPU  
- VGA pixel buffer output  
- `address_map_niosv.h` memory map  
- ACLINT MTIME / MTIMECMP hardware timer  
- Compatible with CPUlator  

---

## Controls

- `KEY0` – Turn right (interrupt-driven)  
- `KEY1` – Turn left (interrupt-driven)  

The human player must avoid:
- Screen boundaries
- Light trails
- Head-on and cross-over collisions

The first player to reach **9 points** wins the game.

---

## Functional Description

### Player State
Each player maintains:
- `(x, y)` position
- Direction (`UP`, `RIGHT`, `DOWN`, `LEFT`)
- Alive/dead state

Player state is updated only during timer interrupts.

---

### Timing and Scheduling
- Game ticks are generated by the MTIME hardware timer
- The timer ISR executes:
  - Player movement
  - AI decision logic
  - Collision detection
- Game speed is adjustable using on-board switches

---

### Interrupt Handling

#### Timer Interrupt (MTIME)
- Drives the main game loop
- Executes movement, AI, and collision logic
- Reschedules the next timer interrupt dynamically

#### Pushbutton Interrupt (KEY)
- Captures user input asynchronously
- Stores pending turn requests
- Applies turns safely on the next timer tick

---

### Collision Detection
The game detects:
- Wall collisions
- Trail collisions
- Head-on collisions
- Cross-over collisions

When a collision occurs:
- The round ends
- A winner is determined
- Scores are updated

---

### AI Behavior
The robot player:
- Attempts to continue moving forward
- Checks one and two pixels ahead for obstacles
- Turns left or right if forward movement is unsafe

---

## Graphics Output

- VGA output is generated by writing directly to the pixel buffer
- A white border and central obstacle define the play area
- Player trails are drawn as solid-colored pixels

---

## Score Display

- Scores are displayed on the `HEX3–HEX0` seven-segment displays
- The game ends when either player reaches 9 points
- The screen fills with the winner’s color at game over

---

## Design Rationale

This version demonstrates a **fully interrupt-driven embedded design**, focusing on:
- Hardware-accurate timing
- Efficient CPU utilization
- Clean separation between input, timing, and game logic

It serves as a direct comparison to the polling-based implementation in a separate repository.

---

## Advantages Over Polling Version

- Precise and stable timing using hardware timers
- Asynchronous input handling
- Reduced CPU idle time
- Improved scalability for additional features

---

## Limitations

- Increased architectural complexity
- Requires correct interrupt and CSR configuration
